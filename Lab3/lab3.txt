// Глобальная переменная для хранения карты высот 
// Ссылка на элемент веб страницы в котором будет отображаться графика
var container;
// Переменные "камера", "сцена" и "отрисовщик"
var camera, scene, renderer;
var imagedata;
var geomerty;
var spotlight = new THREE.PointLight(0xffffff);
var mixer, morphs = [];
var N = 256;
var a = 0.0;
var clock = new THREE.Clock();
// Функция инициализации камеры, отрисовщика, объектов сцены и т.д.
init();
// Обновление данных по таймеру браузера
animate();
treeees();
getRandomInt();
// В этой функции можно добавлять объекты и выполнять их первичную настройку
function init()
{
    // Получение ссылки на элемент html страницы
    container = document.getElementById( 'container' );
    // Создание "сцены"
    scene = new THREE.Scene();
    // Установка параметров камеры
    // 45 - угол обзора
    // window.innerWidth / window.innerHeight - соотношение сторон
    // 1 - 4000 - ближняя и дальняя плоскости отсечения
    camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 4000 );
    // Установка позиции камеры
    camera.position.set(N/2, N/2, N*2);

    // Установка точки, на которую камера будет смотреть
    camera.lookAt(new THREE.Vector3( N/2, 0.0, N/2));
    // Создание отрисовщика
    renderer = new THREE.WebGLRenderer( { antialias: false } );
    renderer.setSize( window.innerWidth, window.innerHeight );
    // Закрашивание экрана синим цветом, заданным в 16ричной системе
    renderer.setClearColor( 0x000000ff, 1);
    container.appendChild( renderer.domElement );
    // Добавление функции обработки события изменения размеров окна
    window.addEventListener( 'resize', onWindowResize, false );

    //создание точечного источника освещения заданного цвета 
    //установка позиции источника освещения 
    spotlight.position.set(100, 100, 100); 
    //добавление источника в сцену 
    scene.add(spotlight);

    var canvas = document.createElement('canvas'); 
    var context = canvas.getContext('2d'); 
    var img = new Image(); 
    
    //создание списка анимаций в функции Init

    
    //глобальные служебные переменные для хранения списка анимаций

    img.src = 'pics/plateau.jpg';
    img.onload = function() 
    {    
        canvas.width = img.width;     
        canvas.height = img.height;     
        context.drawImage(img, 0, 0 );     
        imagedata = context.getImageData(0, 0, img.width, img.height); 
        // Пользовательская функция генерации ландшафта     
        terrain(); 
    } 
    img.src = 'pics/plateau.jpg';

    loadModel('models/', "Tree.obj", "Tree.mtl");
    loadAnimatedModel( 'models/Horse.glb');
    mixer = new THREE.AnimationMixer( scene );
}
function onWindowResize()
{
    // Изменение соотношения сторон для виртуальной камеры
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    // Изменение соотношения сторон рендера
    renderer.setSize( window.innerWidth, window.innerHeight );
}
function animate()
{
    
    var delta = clock.getDelta();
    spotlight.position.x = N/2; 
    spotlight.position.y = 127; 
    camera.lookAt(new THREE.Vector3( N/2, 0.0, N/2));
    a += 0.01; 
    // Добавление функции на вызов, при перерисовки браузером страницы
    requestAnimationFrame( animate );
    render();

       
        mixer.update( delta );

            for ( var i = 0; i < morphs.length; i ++ )
        {
                var morph = morphs[ i ];
        }
}
function render()
{
    // Рисование кадра
    renderer.render( scene, camera );
}
// Создание структуры для хранения вершин
function terrain()
{
    // Создание структуры для хранения вершин
    geometry = new THREE.Geometry();
    for (var i=0; i < N; i++)
        for (var j=0; j < N; j++)
        {
            var y = getPixel( imagedata, i, j );
        // Добавление координат вершин в массив вершин
        geometry.vertices.push(new THREE.Vector3( i, y/10.0, j));
    }
    var c = 0;
    for (var i=0; i < N-1; i++)
        for (var j=0; j < N-1; j++)
        {
            var ind0 = i + j*N;
            var ind1 = (i+1) + j*N;
            var ind2 = (i+1) + (j+1)*N;
            geometry.faces.push(new THREE.Face3( ind0, ind1, ind2));
            var ind3 = i + j*N;
            var ind4 = (i+1) + (j+1)*N;
            var ind5 = i + (j+1)*N;
            geometry.faces.push(new THREE.Face3( ind3, ind4, ind5));
            geometry.faceVertexUvs[0].push([
                new THREE.Vector2(i/(N-1), j/(N-1)),      
                new THREE.Vector2((i+1)/(N-1), j/(N-1)),      
                new THREE.Vector2((i+1)/(N-1), (j+1)/(N-1))]); 
            geometry.faceVertexUvs[0].push([
                new THREE.Vector2(i/(N-1), j/(N-1)),      
                new THREE.Vector2((i+1)/(N-1), (j+1)/(N-1)),      
                new THREE.Vector2(i/(N-1), (j+1)/(N-1))]);
        }
        geometry.computeFaceNormals();  
        geometry.computeVertexNormals(); 
        // Создание загрузчика текстур 
        var loader = new THREE.TextureLoader(); 
        // Загрузка текстуры grasstile.jpg из папки pics 
        var tex = loader.load( 'pics/grasstile.jpg' );
     var mat = new THREE.MeshLambertMaterial({     // Источник цвета - текстура     
        map: tex,     
        wireframe: false,     
        side: THREE.DoubleSide });
    // Создание объекта и установка его в определённую позицию
    var triangleMesh = new THREE.Mesh(geometry, mat);
    scene.add(triangleMesh);
}
function getPixel( imagedata, x, y )  
{     
    var position = ( x + imagedata.width * y ) * 4, data = imagedata.data;     
    return data[ position ];;
} 
function loadModel(path, oname, mname)
{
 // функция, выполняемая в процессе загрузки модели (выводит процент загрузки)
 var onProgress = function ( xhr ) {
 if ( xhr.lengthComputable ) {
 var percentComplete = xhr.loaded / xhr.total * 100;
 console.log( Math.round(percentComplete, 2) + '% downloaded' );
 }
 };
 // функция, выполняющая обработку ошибок, возникших в процессе загрузки
 var onError = function ( xhr ) { };
 // функция, выполняющая обработку ошибок, возникших в процессе загрузки
 var mtlLoader = new THREE.MTLLoader();
 mtlLoader.setPath( path );
 // функция загрузки материала
 mtlLoader.load( mname, function( materials )
 {
 materials.preload();
 var objLoader = new THREE.OBJLoader();
 objLoader.setMaterials( materials );
 objLoader.setPath( path );

 // функция загрузки модели
 objLoader.load( oname, function ( object )
 {
 object.position.x = 5;
 object.position.y = 0;
 object.position.z = 5;
 object.scale.set(0.2, 0.2, 0.2);
 scene.add(object);
 for (var i = 0;i<10;i++)
 {
        treeees(object);

 }
 }, onProgress, onError );
 });
}
function getRandomInt()
{
    return Math.floor(Math.random()*Math.floor(255));
}
function treeees(object)
{
    var createtreees = object.clone()
    var posx = getRandomInt();
    var posy = getRandomInt();
    if(posx)
    createtreees.position.set(getRandomInt(),0,getRandomInt());
    scene.add(createtreees);

}


function loadAnimatedModel(path) //где path – путь и название модели
{
 var loader = new THREE.GLTFLoader();

 loader.load( path, function (  gltf  ) {
 var mesh = gltf.scene.children[ 0 ];
 var clip = gltf.animations[ 0 ];
 //установка параметров анимации (скорость воспроизведения и стартовый фрейм)
 mixer.clipAction( clip, mesh ).setDuration( 1 ).startAt( 0 ).play();
 mesh.position.set( 20, 20, -5 );
 mesh.rotation.y = Math.PI / 8;
 mesh.scale.set( 0.2, 0.2, 0.2 );

 mesh.castShadow = true;
 mesh.receiveShadow = true;

 scene.add( mesh );
 morphs.push( mesh );

 } );
}
// воспроизведение анимаций (в функции animate)
var delta = clock.getDelta();
mixer.update( delta );

for ( var i = 0; i < morphs.length; i ++ )
{
 var morph = morphs[ i ];
}
